【重学Golang】07-错误处理

> 持续创作，加速成长！这是我参与「掘金日新计划 · 6 月更文挑战」的第11天，[点击查看活动详情](https://juejin.cn/post/7099702781094674468)

在 Golang 中，对于一些错误可以预期且不是非常严重，不会影响程序的运行。可以用返回错误的方式返回给调用者，让调用者吹。

## error 接口

### 内置error 

Go 中错误是通过内置的 error 接口表示的。其只有一个 Error 方法用来返回具体的错误信息。

```go
type error interface {
	Error() string
}
```

所以实现该错误处理，只需给 Error() 方法返回一个简单的字符串。

### 自定义 error

```go
type CustomError struct {
  errorcode int
  errormessage string
}
// 实现 Error 方法
func (err CustomError) Error() string{
  return string(err.errormessage)
}
```

以上实现了自定义 error。只需定义一个新的类型，如结构体，然后让这个类型实现 error 接口。自定义 error 可携带更多的信息。

### 错误嵌套

error 接口看起来很简单，但如果需求升级，基于一个存在的 error 再生成一个 error ？如调用一个函数返回一个错误信息，再不丢失错误信息的情况下，添加额外信息返回新的错误信息。

那么只有错误嵌套可以包含多个信息

```go
type MoreError struct {
	err error
	msg string
}

func (merr MoreError) Error() string {
 return merr.err.Error() + merr.msg
}
```

结构体 MoreError 有2个字段，其中 error 类型的 err 字段用于存放已存在的 error，string 类型的 msg 字段用于存放新的错误信息，**这种方式就是 error 的嵌套**。

## Deferred 函数

在进行文件读写时，我们经常打开文件后使用完后一定是需要关闭它，主要是为了保证资源的释放。但有时候处理时很经常就是忘记关闭。

```go
func ReadFile(filename string) ([]byte, error) {
   f, err := os.Open(filename)
   if err != nil {
      return nil, err
   }
   defer f.Close()
   //省略无关代码
   return readAll(f, n)
}
```

关键字 defer ，用于修饰一个函数或者方法，使得该函数或方法在返回前才会被执行，即延迟执行且保证一定会执行。

在一些成对操作的场景里 defer 很经常被使用，如文件的打开和关闭，加锁和释放锁，连接的建立和断开等等。

## Panic 异常

Go 是静态的强类型语言，很多错误都会在编译时捕获，但有些只有在运行时才能检查，如类型转换错误，数组索引越界引起的 panic 异常。

panic 是 Go 语言内置的函数，可以接受 interface{} 类型的参数，也就是任何类型的值都可以传递给 panic 函数，如下所示：

```go
func panic(v interface{})
```

需要注意，panic 会引起程序运行中断，所以在不影响程序运行的错误，不要使用panic 而是使用普通错误 error。